/* Copyright © 2023 App Nerds LLC v1.4.1 */
/**
 * Converts a classic JS object to a Map
 * Copyright © 2023 App Nerds LLC
 * @param o object The object to convert
 * @returns {Map} A Map
 */
const objectToMap=(o={})=>{let e=new Map;for(const t in o)e.set(t,o[t]);return e};
/**
 * BaseView is the base class for all views in the application. It provides
 * a common set of functionality that all views can use. Your view JavaScript
 * components should extend this class and register themselves as custom elements.
 * @class BaseView
 * @extends {HTMLElement}
 * @property {string} title The title of the view. This is used to set the document title.
 * @property {object} params The parameters passed to the view.
 * @property {object} state The state of the view.
 */class BaseView extends HTMLElement{constructor(params,_onRenderComplete){super(),this._title="",this.params=params,this._state={},this._onRenderComplete=window._router.onRenderComplete||null,this.router=window._router}async connectedCallback(){await this.beforeRender(),await this.render(),this._setDocumentTitle(),await this.afterRender(),this._onRenderComplete&&this._onRenderComplete(this)}disconnectedCallback(){this.onUnload()}
/**
	 * This method is called before the view is rendered. Override this method
	 * to perform any actions before the view is rendered.
	 * @returns {Promise<void>}
	 */async beforeRender(){}
/**
	 * This method is called after the view is rendered. Override this method
	 * to perform any actions after the view is rendered.
	 * @returns {Promise<void>}
	 */async afterRender(){}
/**
	 * This method is called when the view is unloaded. Override this method
	 * to perform any actions when the view is unloaded.
	 * @returns {Promise<void>}
	 */async onUnload(){}
/**
	 * This method is called when the view is navigated to. Override this method
	 * render your page contents.
	 * @returns {Promise<void>}
	 */async render(){throw new Error("not implemented")}
/**
	 * Get the title for the current view.
	 * @returns {string}
	 */get title(){return this._title}
/**
	 * Get the HTML for the current view.
	 * @returns {string}
	 */get html(){return this._html}
/**
	 * Get the state for the current view.
	 * @returns {object}
	 */get state(){return this._state}
/**
	 * Set the state for the current view.
	 * @param {object} newState The new state for the view.
	 * @returns {void}
	 */set state(newState){this._state=newState}
/**
	 * Get the value of a query parameter.
	 * @param {string} paramName The name of the query parameter.
	 * @returns {string}
	 */getQueryParam(paramName){return this.router.getQueryParam(paramName)}
/**
	 * Navigate to a new URL.
	 * @param {string} url The URL to navigate to.
	 * @param {object} queryParams Query parameters to add to the URL.
	 * @param {object} state The state to pass to the new view.
	 * @returns {void}
	 */navigateTo(url,queryParams={},state={}){this.router.navigateTo(url,queryParams,state)}_setDocumentTitle(){var e=this.querySelectorAll("title");e&&0<e.length&&(this._title=e[0].innerText,document.title=this._title,this.removeChild(e[0]))}}
/**
 * DefaultPageNotFound is the default view to display when a page is not found.
 * @class DefaultPageNotFound
 * @extends {BaseView}
 */class DefaultPageNotFound extends BaseView{constructor(params){super(params)}async render(){return`
			<title>Page Not Found</title>
			<p>The page ${this.params.path} could not be found.</p>
		`}}customElements.get("default-page-not-found")||customElements.define("default-page-not-found",DefaultPageNotFound)
/** @typedef {object & { path: string, view: BaseView }} Route */
/**
 * Router is responsible for routing requests to the correct view.
 * @class Router
 */;class Router{
/**
	 * Creates a new instance of Router.
	 * @param {string} targetEl The element to render the SPA into.
	 * @param {Array<Route>} routes The routes to use for the SPA.
	 * @param {BaseView} pageNotFoundView The view to use when a route is not found.
	 */
constructor(targetEl,routes,pageNotFoundView=null){this.targetEl=targetEl,this.routes=routes,this.pageNotFoundView=pageNotFoundView,this.beforeRoute=null,this.afterRoute=null,this.injectParams=null,this.onRenderComplete=null,this.pageNotFoundView?this.routes.push({path:"/404notfound/:path",view:this.pageNotFoundView}):this.routes.push({path:"/404notfound/:path",view:DefaultPageNotFound})}
/**
	 * Retrieves a query parameter from the URL by name.
	 * @param {string} paramName The name of the query parameter to retrieve.
	 * @returns {string}
	 */getQueryParam(paramName){let e=new URLSearchParams(location.search);return e.get(paramName)}
/**
	 * Navigates to a URL.
	 * @param {string} url The URL to navigate to.
	 * @param {object} queryParams Query parameters to add to the URL.
	 * @param {object} state The state to pass to the new view.
	 * @returns {void}
	 */navigateTo(url,queryParams={},state={}){let t="";if(0<Object.keys(queryParams).length){var r,o,queryParams=objectToMap(queryParams);t+="?";for([r,o]of queryParams){var a=encodeURIComponent(r);let e=o;"object"==typeof o&&(e=JSON.stringify(o));var n=encodeURIComponent(e);t+=a+`=${n}&`}}history.pushState(state,null,""+url+t),this._route({state:state})}_pathToRegex(path){return new RegExp("^"+path.replace(/\//g,"\\/").replace(/:\w+/g,"(.+)")+"$")}_getParams(match){let e=0;var t=match.result.slice(1),r=Array.from(match.route.path.matchAll(/:(\w+)/g)).map(result=>result[1]);let o={};for(e=0;e<t.length;e++)o[r[e]]=t[e];if(this.injectParams){var a=this.injectParams(match);for(const n in a)o[n]=a[n]}return o}async _route(e){let t={};e.state&&(t=e.state);const r=this.routes.map(route=>({route:route,result:location.pathname.match(this._pathToRegex(route.path))}));let o=r.find(potentialMatch=>null!==potentialMatch.result);
/*
		 * Route not found - return first route
		 */if(o){if(!this.beforeRoute||!1!==this.beforeRoute.apply(this,o.route)){
/*
		 * Get parameters, then initialie the view and render.
		 */
e=this._getParams(o);const a=new o.route.view(e),n=(a.state=t,document.querySelector(this.targetEl));n.innerHTML="",n.appendChild(a),this.afterRoute&&this.afterRoute(o.route)}}else this.navigateTo("/404notfound"+location.pathname)}}
/** @typedef {import("./router.js").Route} Route */
/** @typedef {object & {routes: Array<Route>, targetElement: HTMLElement, router: Router, afterRoute: function, beforeRoute: function, injectParams: function, onRenderComplete: function, go: function }} Application */
/**
 * Creates a new single-page application.
 * @param {HTMLElement} targetElement The element to render the SPA into.
 * @param {Array<Route>} routes The routes to use for the SPA.
 * @param {BaseView} pageNotFoundView The view to use when a route is not found.
 * @returns {Application}
 */const application=(targetElement,routes,pageNotFoundView=DefaultPageNotFound)=>(window._router=new Router(targetElement,routes,pageNotFoundView),window.navigateTo=window._router.navigateTo.bind(window._router),window.addEventListener("popstate",e=>{window._router._route({state:e.state})}),{routes:routes,targetElement:targetElement,router:window._router,afterRoute:f=>{window._router.afterRoute=f.bind(window._router)},beforeRoute:f=>{window._router.beforeRoute=f.bind(window._router)},injectParams:f=>{window._router.injectParams=f.bind(window._router)},onRenderComplete:f=>{window._router.onRenderComplete=f.bind(window._router)},go:()=>{window._router._route({})}});export{application};