/* Copyright Â© 2023 App Nerds LLC v1.4.2 */
/**
 * A wrapper around fetch that will show a spinner
 * while the request is being made. This is useful for
 * long running requests.
 * @param {string} url The URL to fetch
 * @param {object} options The fetch options
 * @param {object} spinner The spinner element to show
 * @param {number} msBeforeShowSpinner The number of milliseconds to wait before showing the spinner. Default is 1000
 * @returns {Promise<object>} A promise that resolves to the fetch response
 */
async function fetcher(url,options,spinner,msBeforeShowSpinner=1e3){let e,t;spinner&&(e=setTimeout(()=>{spinner.show()},msBeforeShowSpinner));try{t=await fetch(url,options)}finally{spinner&&(clearTimeout(e),spinner.hide())}return t}
/** @typedef { object & { http: fetcher, tokenGetterFunction: function, expiredTokenCallback: function, spinner: object, navigateTo: function } } GraphQLOptions */
/**
 * This class is a wrapper around the fetcher function
 * that makes it easy to execute GraphQL queries and mutations.
 * It also handles expired tokens.
 * @class GraphQL
 * @param {string} queryURL The URL to the GraphQL API
 * @param {GraphQLOptions} options Options for the GraphQL class
 */class GraphQL{constructor(queryURL,options={http:fetcher,tokenGetterFunction:null,expiredTokenCallback:null,spinner:null,navigateTo:null}){options={http:fetcher,tokenGetterFunction:null,expiredTokenCallback:null,spinner:null,navigateTo:null,...options},this.queryURL=queryURL,this.http=options.http,this.tokenGetterFunction=options.tokenGetterFunction,this.expiredTokenCallback=options.expiredTokenCallback,this.spinner=options.spinner,this.navigateTo=options.navigateTo}
/**
	 * Executes a query against a GraphQL API
	 * @param query string A graphql query. Omit the "query {}" portion.
	 * @returns {Promise<object>} A promise that resolves to the fetch response
	 */async query(query){if(!this.expiredTokenCallback||this.expiredTokenCallback(null,"/",this.navigateTo)){var n=this.tokenGetterFunction?this.tokenGetterFunction():"";query=`query {
			${query}
		}`;let e={method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:query})},t=(n&&(e.headers.Authorization="Bearer "+n),await this.http(this.queryURL,e,this.spinner));if(400!==t.status&&401!==t.status){query=await t.json();if(t.ok)return query;throw new Error(query.message)}this.expiredTokenCallback&&this.expiredTokenCallback(t,"/",this.navigateTo)}}
/**
	 * Executes a mutation against a GraphQL API
	 * @param query string A graphql mutation. Omit the "mutation {}" portion
	 * @returns {Promise<object>} A promise that resolves to the fetch response
	 */async mutation(query){if(!this.expiredTokenCallback||this.expiredTokenCallback(null,"/",this.navigateTo)){var n=this.tokenGetterFunction?this.tokenGetterFunction():"";query=`mutation {
			${query}
		}`;let e={method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query:query})},t=(n&&(e.headers.Authorization="Bearer "+n),await this.http(this.queryURL,e,this.spinner));if(400!==t.status&&401!==t.status){query=await t.json();if(t.ok)return query;throw new Error(query.message)}this.expiredTokenCallback&&this.expiredTokenCallback(t,"/",this.navigateTo)}}}export{GraphQL,fetcher};